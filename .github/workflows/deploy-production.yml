# =========================================================================
# WORKFLOW: Deploy para Ambiente de Produ칞칚o
# =========================================================================
# Este workflow valida PRs direcionados  branch `main`.
# Build e deploy usam imagens com tag `latest` (sem versionamento sem칙ntico).
# Observa칞칚o: as etapas de build/deploy est칚o condicionadas a eventos `push`.
# Para acionar deploy em `push` para `main`, veja coment치rio na se칞칚o `on:`.
# Requisitos: runner self-hosted com Docker e AWS CLI (para comandos `aws`).
# ========================================================================= 

name: (CI/CD) Deploy Ambiente de Produ칞칚o

on:
  pull_request:
    branches:
      - main
    types: [opened, synchronize, reopened]
# ----------------------------------------------------------------------------
  # OBS: Atualmente este workflow s칩 칠 acionado em `pull_request` para `main`.
  # Se desejar executar build e deploy em `push` para `main`, adicione:
  # push:
  #   branches: [main]
  # --------------------------------------------------------------------------

jobs:
  build-and-deploy:
    environment: app-personal-contact-production
    runs-on: [self-hosted, production-runner]
    permissions:
      contents: read

    steps:
      # Faz checkout do c칩digo do reposit칩rio
      - name: Checkout do c칩digo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Configura Docker Buildx para builds otimizados
      - name: Configurar Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Configura credenciais AWS para ECR e CLI
      - name: Configurar credenciais AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_PROD }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_PROD }}
          aws-region: ${{ secrets.AWS_REGION_PROD }}

      # Realiza login no Amazon ECR
      - name: Login no Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      # Build e push da imagem do backend (latest)
      - name: Build e push Backend para ECR (latest)
        if: github.event_name == 'push'
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY_BACKEND_PROD }}
          IMAGE_TAG: latest
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG ./backend
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG

      # Build e push da imagem do frontend (latest)
      - name: Build e push Frontend para ECR (latest)
        if: github.event_name == 'push'
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY_FRONTEND_PROD }}
          IMAGE_TAG: latest
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG ./frontend
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG

      # Realiza deploy na EC2 (db, backend, frontend)
      - name: Deploy na inst칙ncia EC2
        if: github.event_name == 'push'
        env:
          IMAGE_TAG: latest
        run: |
          aws configure set default.region ${{ secrets.AWS_REGION_PROD }}
          docker stop contacts-frontend-production contacts-backend-production contacts-db-production || true
          docker rm contacts-frontend-production contacts-backend-production contacts-db-production || true
          docker run --restart unless-stopped -d --name contacts-db-production \
            -e POSTGRES_USER=${{ secrets.POSTGRES_USER_PROD }} \
            -e POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD_PROD }} \
            -e POSTGRES_DB=${{ secrets.POSTGRES_DB_PROD }} \
            -v contacts_data_production:/var/lib/postgresql/data \
            postgres:13-alpine
          sleep 15
          docker pull ${{ steps.login-ecr.outputs.registry }}/${{ secrets.ECR_REPOSITORY_BACKEND_PROD }}:$IMAGE_TAG
          docker run --restart unless-stopped -d --name contacts-backend-production \
            -p ${{ secrets.BACKEND_PORT_PROD }}:${{ secrets.BACKEND_PORT_PROD }} \
            --env PORT=${{ secrets.BACKEND_PORT_PROD }} \
            --env DATABASE_URL=postgresql://${{ secrets.POSTGRES_USER_PROD }}:${{ secrets.POSTGRES_PASSWORD_PROD }}@contacts-db-production:5432/${{ secrets.POSTGRES_DB_PROD }} \
            --env JWT_SECRET=${{ secrets.JWT_SECRET_PROD }} \
            --env JWT_EXPIRES_IN=${{ secrets.JWT_EXPIRES_IN_PROD }} \
            --link contacts-db-production:contacts-db-production \
            ${{ steps.login-ecr.outputs.registry }}/${{ secrets.ECR_REPOSITORY_BACKEND_PROD }}:$IMAGE_TAG
          docker pull ${{ steps.login-ecr.outputs.registry }}/${{ secrets.ECR_REPOSITORY_FRONTEND_PROD }}:$IMAGE_TAG
          docker run --restart unless-stopped -d --name contacts-frontend-production \
            -p 80:80 \
            --link contacts-backend-production:app \
            --env BACKEND_HOST=app \
            ${{ steps.login-ecr.outputs.registry }}/${{ secrets.ECR_REPOSITORY_FRONTEND_PROD }}:$IMAGE_TAG

      # Verifica containers ativos e portas expostas
      - name: Verificar deploy
        run: |
          echo "游늵 Status do deploy:"
          docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"

      # Remove imagens n칚o utilizadas para liberar espa칞o
      - name: Limpeza
        run: docker image prune -f || true