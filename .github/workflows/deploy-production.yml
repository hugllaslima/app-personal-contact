# =========================================================================
# WORKFLOW: Deploy para Ambiente de Produ√ß√£o
# =========================================================================
# Este workflow √© executado quando um PR √© aberto para a branch main.
# Realiza o versionamento autom√°tico, build, push para ECR e deploy da aplica√ß√£o.
# =========================================================================

name: (CI/CD) Deploy Ambiente de Produ√ß√£o

on:
  pull_request:
    branches:
    - main

jobs:
  build-and-deploy:
    environment: app-personal-contact-production
    runs-on: [self-hosted, production-runner]

    steps:
    # =========================================================================
    # PREPARA√á√ÉO DO AMBIENTE
    # =========================================================================
    
    # Limpa o workspace para evitar conflitos com execu√ß√µes anteriores
    - name: Limpar workspace
      run: rm -rf ./* ./.* 2>/dev/null || true

    # Checkout do c√≥digo com token de acesso para permitir commits
    - name: Checkout do c√≥digo
      uses: actions/checkout@v4
      with: 
        fetch-depth: 0  # Hist√≥rico completo para versionamento
        clean: true
        token: ${{ secrets.PAT_TOKEN }}

    # Configura o Git para realizar commits automatizados
    - name: Configurar Git
      run: |
        git config --global user.email "actions@github.com"
        git config --global user.name "GitHub Actions Bot"
        git remote set-url origin https://x-access-token:${{ secrets.PAT_TOKEN }}@github.com/${{ github.repository }}.git

    # Configura a branch local para trabalhar com a branch do PR
    - name: Configurar branch local
      run: |
        BRANCH_NAME="${{ github.head_ref }}"
        git fetch origin
        git checkout -B "$BRANCH_NAME" "origin/$BRANCH_NAME"
        git branch --set-upstream-to="origin/$BRANCH_NAME" "$BRANCH_NAME"

    # =========================================================================
    # AN√ÅLISE DE VERSIONAMENTO
    # =========================================================================
    
    # Determina o tipo de versionamento baseado no nome da branch
    - name: Determinar tipo de versionamento
      id: version-type
      run: |
        BRANCH_NAME="${{ github.head_ref }}"
        
        if [[ "$BRANCH_NAME" == feature/* ]]; then
          echo "type=minor" >> $GITHUB_OUTPUT
          echo "release_type=production" >> $GITHUB_OUTPUT
          echo "description=Nova funcionalidade" >> $GITHUB_OUTPUT
          echo "emoji=‚ú®" >> $GITHUB_OUTPUT
        elif [[ "$BRANCH_NAME" == hotfix/* ]]; then
          echo "type=patch" >> $GITHUB_OUTPUT
          echo "release_type=production" >> $GITHUB_OUTPUT
          echo "description=Corre√ß√£o de bug" >> $GITHUB_OUTPUT
          echo "emoji=üêõ" >> $GITHUB_OUTPUT
        elif [[ "$BRANCH_NAME" == release/* ]]; then
          echo "type=minor" >> $GITHUB_OUTPUT
          echo "release_type=production" >> $GITHUB_OUTPUT
          echo "description=Release oficial" >> $GITHUB_OUTPUT
          echo "emoji=üöÄ" >> $GITHUB_OUTPUT
        else
          echo "type=patch" >> $GITHUB_OUTPUT
          echo "release_type=production" >> $GITHUB_OUTPUT
          echo "description=Atualiza√ß√£o de produ√ß√£o" >> $GITHUB_OUTPUT
          echo "emoji=‚öôÔ∏è" >> $GITHUB_OUTPUT
        fi

    # =========================================================================
    # CONFIGURA√á√ÉO DE AMBIENTES
    # =========================================================================
    
    # Configura Python para o backend
    - name: Configurar Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    # Configura Node.js para o frontend
    - name: Configurar Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'

    # =========================================================================
    # VERSIONAMENTO FRONTEND
    # =========================================================================
    
    # Instala depend√™ncias do frontend
    - name: Instalar depend√™ncias do frontend
      working-directory: ./frontend
      run: npm install

    # Garante que standard-version est√° instalado
    - name: Configurar standard-version
      working-directory: ./frontend
      run: |
        if ! npm list standard-version > /dev/null 2>&1; then
          npm install --save-dev standard-version
        fi

    # Aplica o versionamento no frontend
    - name: Versionamento Frontend
      working-directory: ./frontend
      run: npm run release -- ${{ steps.version-type.outputs.type }} --skip.tag --no-verify

    # =========================================================================
    # VERSIONAMENTO BACKEND
    # =========================================================================
    
    # Instala depend√™ncias do backend
    - name: Instalar depend√™ncias do backend
      working-directory: ./backend
      run: |
        python -m pip install --upgrade pip
        pip install bump2version commitizen python-standard-version
        if [ -f "requirements.txt" ]; then
          pip install -r requirements.txt
        fi

    # Aplica o versionamento no backend
    - name: Versionamento Backend
      working-directory: ./backend
      run: |
        # Extrai a vers√£o atual do pyproject.toml
        CURRENT_VERSION=$(grep 'version = ' pyproject.toml | cut -d'"' -f2 | head -1)
        
        # Aplica o versionamento usando commitizen
        python -m commitizen bump --increment ${{ steps.version-type.outputs.type }} --no-verify
        
        # Verifica a nova vers√£o
        NEW_VERSION=$(grep 'version = ' pyproject.toml | cut -d'"' -f2 | head -1)
        echo "‚úÖ Nova vers√£o do backend: $NEW_VERSION"
        
    # =========================================================================
    # GERENCIAMENTO DE TAGS
    # =========================================================================
    
    # Cria tag baseada nas vers√µes atualizadas
    - name: Criar tag
      id: tag
      run: |
        # Extrai as vers√µes atualizadas
        FRONTEND_VERSION=$(cd frontend && node -p "require('./package.json').version" 2>/dev/null || echo 'N/A')
        BACKEND_VERSION=$(cd backend && grep 'version = ' pyproject.toml | cut -d'"' -f2 | head -1 2>/dev/null || echo 'N/A')
        
        # Define o nome da tag baseado na vers√£o do frontend
        TAG_NAME="v${FRONTEND_VERSION}"
        
        # Exporta as vari√°veis para uso em outros steps
        echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
        echo "frontend_version=$FRONTEND_VERSION" >> $GITHUB_OUTPUT
        echo "backend_version=$BACKEND_VERSION" >> $GITHUB_OUTPUT

    # =========================================================================
    # COMMIT E PUSH
    # =========================================================================
    
    # Realiza commit das altera√ß√µes de versionamento
    - name: Commit das altera√ß√µes
      run: |
        git add .
        if ! git diff --cached --quiet; then
          # Commit seguindo Conventional Commits
          git commit -m "${{ steps.version-type.outputs.emoji }} chore(release): bump versions to ${{ steps.tag.outputs.frontend_version }}

          ${{ steps.version-type.outputs.description }}
          
          üì¶ Versionamento:
          ‚Ä¢ Frontend: ${{ steps.tag.outputs.frontend_version }}
          ‚Ä¢ Backend: ${{ steps.tag.outputs.backend_version }}
          ‚Ä¢ Ambiente: ${{ steps.version-type.outputs.release_type }}
          ‚Ä¢ Tipo: ${{ steps.version-type.outputs.type }}
          ‚Ä¢ Branch: ${{ github.head_ref }}
          
          Co-authored-by: GitHub Actions <actions@github.com>"
        fi

    # Push das altera√ß√µes e cria√ß√£o da tag
    - name: Push e criar tag
      run: |
        BRANCH_NAME="${{ github.head_ref }}"
        
        # Push para a branch do PR
        git push origin "$BRANCH_NAME"
        
        # Criar tag local (ser√° enviada para o reposit√≥rio quando merger)
        git tag -a "${{ steps.tag.outputs.tag_name }}" -m "${{ steps.version-type.outputs.emoji }} Release ${{ steps.tag.outputs.tag_name }}

        üöÄ Deploy ${{ steps.version-type.outputs.description }}
        ‚Ä¢ Frontend: ${{ steps.tag.outputs.frontend_version }}
        ‚Ä¢ Backend: ${{ steps.tag.outputs.backend_version }}
        ‚Ä¢ Ambiente: Produ√ß√£o (${{ steps.version-type.outputs.release_type }})
        ‚Ä¢ Data: $(date '+%d/%m/%Y %H:%M')
        
        Criado automaticamente pelo GitHub Actions"

    # =========================================================================
    # CONFIGURA√á√ÉO AWS E ECR
    # =========================================================================
    
    # Configura Docker Buildx para builds otimizados
    - name: Configurar Docker Buildx
      uses: docker/setup-buildx-action@v3

    # Configura credenciais da AWS
    - name: Configurar credenciais AWS
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_PROD }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_PROD }}
        aws-region: ${{ secrets.AWS_REGION_PROD }}

    # Login no Amazon ECR
    - name: Login no Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    # =========================================================================
    # BUILD E PUSH PARA ECR
    # =========================================================================
    
    # Build, tag e push da imagem Backend para ECR
    - name: Build e push Backend para ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY_BACKEND_PROD }}
        IMAGE_TAG: ${{ steps.tag.outputs.tag_name }}
      run: |
        # Build da imagem
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG ./backend
        
        # Push da imagem com tag de vers√£o
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        
        # Tag e push da imagem como latest
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

    # Build, tag e push da imagem Frontend para ECR
    - name: Build e push Frontend para ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY_FRONTEND_PROD }}
        IMAGE_TAG: ${{ steps.tag.outputs.tag_name }}
      run: |
        # Build da imagem com configura√ß√£o para produ√ß√£o
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
          --build-arg REACT_APP_API_BASE_URL=http://${{ secrets.EC2_HOST_PROD }}:${{ secrets.BACKEND_PORT_PROD }}/api \
          ./frontend
        
        # Push da imagem com tag de vers√£o
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        
        # Tag e push da imagem como latest
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

    # =========================================================================
    # DEPLOY NA INST√ÇNCIA EC2
    # =========================================================================
    
    # Deploy das imagens na inst√¢ncia EC2
    - name: Deploy na inst√¢ncia EC2
      run: |
        # Configurar AWS CLI
        aws configure set default.region ${{ secrets.AWS_REGION_PROD }}
        
        # Para e remove containers existentes
        docker stop contacts-frontend-production contacts-backend-production contacts-db-production || true
        docker rm contacts-frontend-production contacts-backend-production contacts-db-production || true
        
        # Inicia o banco de dados PostgreSQL
        docker run --restart unless-stopped -d --name contacts-db-production \
          -e POSTGRES_USER=${{ secrets.POSTGRES_USER_PROD }} \
          -e POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD_PROD }} \
          -e POSTGRES_DB=${{ secrets.POSTGRES_DB_PROD }} \
          -v contacts_data_production:/var/lib/postgresql/data \
          postgres:13-alpine
        
        # Aguarda inicializa√ß√£o do banco
        sleep 15
        
        # Puxa e inicia o Backend do ECR
        docker pull ${{ steps.login-ecr.outputs.registry }}/${{ secrets.ECR_REPOSITORY_BACKEND_PROD }}:latest
        docker run --restart unless-stopped -d --name contacts-backend-production \
          -p ${{ secrets.BACKEND_PORT_PROD }}:${{ secrets.BACKEND_PORT_PROD }} \
          --env PORT=${{ secrets.BACKEND_PORT_PROD }} \
          --env DATABASE_URL=postgresql://${{ secrets.POSTGRES_USER_PROD }}:${{ secrets.POSTGRES_PASSWORD_PROD }}@contacts-db-production:5432/${{ secrets.POSTGRES_DB_PROD }} \
          --env JWT_SECRET=${{ secrets.JWT_SECRET_PROD }} \
          --env JWT_EXPIRES_IN=${{ secrets.JWT_EXPIRES_IN_PROD }} \
          --link contacts-db-production:contacts-db-production \
          ${{ steps.login-ecr.outputs.registry }}/${{ secrets.ECR_REPOSITORY_BACKEND_PROD }}:latest
        
        # Puxa e inicia o Frontend do ECR
        docker pull ${{ steps.login-ecr.outputs.registry }}/${{ secrets.ECR_REPOSITORY_FRONTEND_PROD }}:latest
        docker run --restart unless-stopped -d --name contacts-frontend-production \
          -p 80:80 \
          --link contacts-backend-production:app \
          ${{ steps.login-ecr.outputs.registry }}/${{ secrets.ECR_REPOSITORY_FRONTEND_PROD }}:latest

    # =========================================================================
    # VERIFICA√á√ÉO E LIMPEZA
    # =========================================================================
    
    # Verifica o status do deploy
    - name: Verificar deploy
      run: |
        echo "üìä Status do deploy:"
        docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
        
        echo ""
        echo "üéâ Deploy de produ√ß√£o conclu√≠do!"
        echo "üì¶ Vers√µes deployadas:"
        echo "   Frontend: ${{ steps.tag.outputs.frontend_version }}"
        echo "   Backend: ${{ steps.tag.outputs.backend_version }}"
        echo "   Tag: ${{ steps.tag.outputs.tag_name }}"

    # Limpa imagens n√£o utilizadas para economizar espa√ßo
    - name: Limpeza
      run: docker image prune -f || true
